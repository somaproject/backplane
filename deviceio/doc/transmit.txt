Transmission is more complex than it appears on the surface. 

Each device on the link can send one event per event cycle. However,
in an effort to reduce latency, they are allowed to do this any time
within the first 4/5ths of an event cycle and be guaranteed that the
event will be brodcast during the next event cycle.

The bus timing is allocated as follows:

wait for an ECYCLE

1. if there is a pending event A, send it
2. if there is a pending event B, send it
3. if there is a pending data byte, send 64 bytes of it

What if, on tick 390, A and B begin writing events to the event buffers; they will register as "done" 20 ticks later. 
Then imagine the worst-case cycle of on cycle 418 we move to the request-to-send-data cycle and we send 64 bytes; then we're at 484 and need to send two events; you lose. 

The easiest solution is simply have the main FSM only send event packets in the final 80 ticks. 

Note that our design is such that we send a K28.5 at the beginning of each cycle for locking and latency measurement. 






\section{Event TX} 

Each device can send one event per ECYCLE; this event is guaranteed to
be transmitted on the next ECYCLE. This is regulated/guaranteed by the
Send Valid (SVALID) signal on the device event interface; only write
an event burst while this signal is high.

\section{Data TX}
We send, at most, 32-byte bursts, with a header and footer k-char

In the implementation, we register all output signals except for DOB
to compensate for the one-cycle latency in the ram.

