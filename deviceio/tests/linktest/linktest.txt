This is our instantiable link test. 

The link test itself is simple; we simply serialize out the bits on one side of the block ram and test that those are the bytes we receive on the other (in the other clock domain). 

The status LEDs are:

LEDPOWER: Flashes to show system is down. uh, I mean on. 
LEDERROR: high for any inbound packets with errors
LEDVALID : high if the past 150 ms of events were valid

This is our log of our attempt to make the serial interface actually
work using a Spartan-3 XC3S200 FPGA and the ideas and codebase behind
Xilinx application note XAPP224.


We take the original source and have performed the following initial modifications:

1. slow it way the fuck down to 70 MHz. DCMs no longer clock double. 

2. Replace the LVDS IO with regular single-ended IOBs, and use
   adjacent IOBs for TX and RX, and (using a drop of solder) short
   them together on the device.

This synthesizes and actually works; there's a minor cheat here,
however -- since we're on the same device, our RX and TX clocks are
exactly aligned.  We never run fast or slow. 

Now in our usage case we never want to deal with the too-many-bytes
case, which tremendously simplifies (*) our implementation, but
creates an artifact where we need to somehow run one clock epsilon
faster than the other. Unfortunately, we use the spartan-3 DCMs for this, and run the RX clock 32/31* faster than the the TX clock. 

3. Configure a separate DCM to feed a 32/31* clock into the RX side of
   things; this means that for every 32 bits received, 1 is a
   no-op. The (Xilinx) designs seem like they should be able to handle
   this without problem.

4. Unfortunately, in this configuration, -any- time we have the RX
   clock intentionally faster than the TX clock we run into all manner
   of error. We can't keep the lock -- we get a match for 100 ns and
   then nothing for 1 us.

What are the potential candidate problems: a. something in the
  start-up. This is less preposterous than it sounds -- for some
  reason, the Xilinx design is very (too?) sensitive to start-up
  effects.


-------------------------------------------------------------------------
Using the LVDS loop-back connector. 

We've isolated the problem (via the logic analyzer) to only occuring:
1. when using the 32/31 receive clock
2. when using any word that has a constant bit run length > 4

This occurs with 

recover.biterrorsxilinx.vhd

Now I'm going to try and replace/substitute-in my recovery HW and see if we get the same behavior. 


We've found that we can successfully recover:
0x55555555
0x55554555
but not 0x55558555

The problem is that our transitions are occuring -waaay- too frequently; the edge can move in as few as 3 clock ticks. Since we can have expanses far longer than this, there's just no way of detecting them. 

So we need to slow our RX clock differential. 



----------------------------------------------------------------

So we can successfully transmit 0x12345678 at 66 MHz (x1) via LVDS using both the single 32/31 clock (r1289) and the 21/20*31/32 clock. 

Now we're going to try with the 125 Mhz clock. 

At 125 MHz, with 32/31=1.032, we can get 0x12345676, i.e. a sequence with a run of 4, without problem. As well as a run of 5, 1F1F0F51

20/21*31/32 (1.01718) fails, however. 

But 29/30*15/14. = 1.0357 works with 55555555


-------------------------------------------------------
there's the thought that perhaps DCI doesn't actually handle load resistors, for LVDS. That would be kinda funny. 

At this point, about the only thing I can think of is that it's some sort of LVDS SI-issue. So our solution is to try and build two little LVDS test boards, modeled after the Spartan-3 High Speed Serial board

The system sure as heck doesn't actually work at 250 Mhz; so the issue of an LVDS test board comes up. Such a board would need a loopback device, some connectors, and a pony. 

But for this afternoon, we're going to put up our serial hat and just do analog work while we wait on a response from comp.arch.fpga  and screaming circuits. 
----------------------------------------------------------


Linktest attempt #2 witht he Soma SerialIO Proto Board

We have it currently working using virtually the same code from before, but on the SerialIO board, using the SATA Loopback connector. 


The SATA loopback connector (at 125 MHz) "mostly" works -- we seem to get single-bit errors every few seconds. But when I try to move to the DIN->DOUT single-ended approach, I get continual errors.

Switching to the 0x55555555 test sequenece. Now, we're not reporting any validity-checking errors. 


We can get this all to work at 125 MHz with the DIN->DOUT non-lvds loopback, but our logicanalyzer can't read the bits fast enough (!) 

So we're going to come up with a little thing I'll call, for lack of a better term, tinyscope. 

--------------------------------------------------------------
With a functioning, compiled tinyscope, running at 140 MHz with an 0x55555555 pattern and the non-lvds on-pcb loopback, we get success. 

0x3333333 appears to work correctly at 140 Mhz too. 

Despite synthesizing correctly, 0x55556555 doesn't work at 143 Mhz, with occsional bit errors, but works fine at 137.5 Mhz. 

Based on my initial analysis it appears that the bit errors are occuring when jitter coupled with (perhaps) DC offset leads to the creation of a short sequence of either 000 or 111.

However, the current clock configuration has us oversampling by 3.57%; I'm reducing that to 3.22 % (via simple 32/31) in hopes that we'll see some sort of improvement due to less clock jitter. 


Why does this work at (29/30*15/14=3.57) but not at (32/31 = 3.22%?). 

The current chunk of data has an error in it from running at 132 MHz
on an 0xF0F070F0 pattern with a 32/31 oversampling ratio from a single
DCM. In synthesis this bitstream had a 124 ps skew. 

----------------------------------------------------------------------------
When we examine the extracted data, we see a case where we have a
3-bit-wide symbol. This is totally unexpected due to our
apparently-high rate of oversampling, and I'm not sure what is causing
it.



This results in tran30 -> tran01 -> tran30, or sposl going 0 1 0 

I think we need to address this from a different perspective, because
if these are the sorts of bits we're pulling out, we're in trouble.

We bumped up the clock rate to 143 MHz to get detectable errors. 


So at the moment, we had things working at 150 MHz with 1x clocking; when we move to 2x clocking, we get continual errors every word. 

-----------------------------------------------------------------------------

We appear to have everything working again, with no strange start-up
bugs, at 150 MHz single-clocked (r1305), over the LVDS IO. 

If I then cut the source frequency by half, and use clock-doubling, I can't even apparently boot. 
