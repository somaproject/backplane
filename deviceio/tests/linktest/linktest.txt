This is our instantiable link test. 

The link test itself is simple; we simply serialize out the bits on one side of the block ram and test that those are the bytes we receive on the other (in the other clock domain). 

The status LEDs are:

LEDPOWER: Flashes to show system is down. uh, I mean on. 
LEDERROR: high for any inbound packets with errors
LEDVALID : high if the past 150 ms of events were valid

This is our log of our attempt to make the serial interface actually
work using a Spartan-3 XC3S200 FPGA and the ideas and codebase behind
Xilinx application note XAPP224.


We take the original source and have performed the following initial modifications:

1. slow it way the fuck down to 70 MHz. DCMs no longer clock double. 

2. Replace the LVDS IO with regular single-ended IOBs, and use
   adjacent IOBs for TX and RX, and (using a drop of solder) short
   them together on the device.

This synthesizes and actually works; there's a minor cheat here,
however -- since we're on the same device, our RX and TX clocks are
exactly aligned.  We never run fast or slow. 

Now in our usage case we never want to deal with the too-many-bytes
case, which tremendously simplifies (*) our implementation, but
creates an artifact where we need to somehow run one clock epsilon
faster than the other. Unfortunately, we use the spartan-3 DCMs for this, and run the RX clock 32/31* faster than the the TX clock. 

3. Configure a separate DCM to feed a 32/31* clock into the RX side of
   things; this means that for every 32 bits received, 1 is a
   no-op. The (Xilinx) designs seem like they should be able to handle
   this without problem.

4. Unfortunately, in this configuration, -any- time we have the RX
   clock intentionally faster than the TX clock we run into all manner
   of error. We can't keep the lock -- we get a match for 100 ns and
   then nothing for 1 us.

What are the potential candidate problems: a. something in the
  start-up. This is less preposterous than it sounds -- for some
  reason, the Xilinx design is very (too?) sensitive to start-up
  effects.


-------------------------------------------------------------------------
Using the LVDS loop-back connector. 

We've isolated the problem (via the logic analyzer) to only occuring:
1. when using the 32/31 receive clock
2. when using any word that has a constant bit run length > 4

This occurs with 

recover.biterrorsxilinx.vhd

Now I'm going to try and replace/substitute-in my recovery HW and see if we get the same behavior. 


We've found that we can successfully recover:
0x55555555
0x55554555
but not 0x55558555

The problem is that our transitions are occuring -waaay- too frequently; the edge can move in as few as 3 clock ticks. Since we can have expanses far longer than this, there's just no way of detecting them. 

So we need to slow our RX clock differential. 



----------------------------------------------------------------

So we can successfully transmit 0x12345678 at 66 MHz (x1) via LVDS using both the single 32/31 clock (r1289) and the 21/20*31/32 clock. 

Now we're going to try with the 125 Mhz clock. 

At 125 MHz, with 32/31=1.032, we can get 0x12345676, i.e. a sequence with a run of 4, without problem. As well as a run of 5, 1F1F0F51

20/21*31/32 (1.01718) fails, however. 

But 29/30*15/14. = 1.0357 works with 55555555


-------------------------------------------------------
there's the thought that perhaps DCI doesn't actually handle load resistors, for LVDS. That would be kinda funny. 

At this point, about the only thing I can think of is that it's some sort of LVDS SI-issue. So our solution is to try and build two little LVDS test boards, modeled after the Spartan-3 High Speed Serial board

The system sure as heck doesn't actually work at 250 Mhz; so the issue of an LVDS test board comes up. Such a board would need a loopback device, some connectors, and a pony. 

But for this afternoon, we're going to put up our serial hat and just do analog work while we wait on a response from comp.arch.fpga  and screaming circuits. 
----------------------------------------------------------


Linktest attempt #2 witht he Soma SerialIO Proto Board

We have it currently working using virtually the same code from before, but on the SerialIO board, using the SATA Loopback connector. 



