Goals:

Generic IO? 

16 DACs (12 bit, 100 ksps max)
16 ADCs?
64 digital out
   output patterns, 
64 digital in

fiber tranceiver

Have a "generic IO" board ala network board? 

Problems: cost ($150 for board)

Hmmm....
this is ass...

Ideally, we have our UI board and our general IO board, well, the same PCB, except that the UI board needs to be soldered to the front of the PCB...
wait, why? Why not have a wimpy little daughter board? 

Use ADSP-21262? What do we want? 


Digital Ouput:
Patterns
  write frequency multiple, bitmask 
  write triggering event
individual bit flipping
time-related flipping (i.e. toggle low-high every n clock ticks)

digital input: 
  fire event foo when inputs match pattern bar
  interrupts (low-> high, high->low)

For both digital and analog: the criticism could be made that we should just use a larger FPGA with more IO. While this is true, we'd still need to do line-level conversion, which would necessitate the same number of 8-bit ICs. (8 total). So we may just as well bite the bullet and do serial stuff, and use an FPGA where we already know dimensions, etc. 


analog output:
   arbitrary value, i.e. buffering the output
   triggerable, n-sample memories
   TLV5630 really looks like best part, but the 
   AD5383 is pretty sweet too (32 chan 12 bit) [ oh, but really expensive!]

   if you really care about analog whatever, use the fiber interface outputs....

   we can have an internal 16-bit set of converters on the tiny 2-layer board... oh that rocks... we can use little SMT connectors for the BNC : ) it can be the oscope-monitoring devices...



ADCs:
   only a read-result system... 16 x 10 bit
   AD7918BRU -- $6.00 8 x 10 bit


UI: daughterboard is pretty much just generic IO, because the digital switch thingies (cheap)

Apollodisplays.com has really good prices on optrex displays

use 68HC12 and FPGA mem-mapping... something something...
wow, you could actually have a high-level interface on the FPGA. Wow, that would be pretty cool. 


UI ...

Well, so, I'm investigating a uP core for the FPGA to handle the LCD stuff... currently the best candidate is pAVR, which is written by a BU student, which is pretty cool. It will synthesize in a Spartan-3 200, which nuhorizons finally has in quantity. 

There also appear to be gcc tools targeted at the avr line of microcontrollers, and people aren't paranoid about legal issues with the open cores. 

It would be neat to have this core running, talking to the FPGA which was doing some measure of hardware-accelerated graphics somethingsomething. 

A lot of the existing cores either 1. suck, 2. are huge, or 3. run into IP concerns. For example, openrisc1200 is freaking huge. 

But after talking with dave w and vimal, they really suggested I go with the openrisc core, and try and look at removing some of the stuff I don't need. Their thoughts were: 1. it'll give me some room to breath in terms of expandability and 2. It's really really (!) well supported. Dave called the code "beautiful" (his crypto-fpga-urop last summer used it). 


So, if we do that, how do we handle memory for the chip, and sequencing issues? I'd like to avoid mating the silicon with an infinite supply of memory... At the same time, it's neat to think of having the machine have a 2 KB (1 block) "command window" that it can just write stuff into, and then the fpga takes controll of that buffer and _thats_ what gets generated. The ideal design is to have something where, every frame, 
1. fpga processes cmd buffer into ram buf a
2. fpga blts ram buf b

with a and b alternating

 the only challenge is that, due to the data rate of the LCD, we'll probably need to s l o w l y pull data out of the ram Actually, not ture -- optrex 4-bit interface seems to suggest that the line cycle time is 0.0556 ms, and total frame is 240x that, or... 13 ms total. That's actually quite a bit of time... but... hmm

we can render to an internal buffer, and during that time pull the necessary data from the memory


Using optrex CFL-backlit transmissive  Black & Wite LCD because these are "the best" something something. interface is tardeaux-easy. Optrex appears to make converter (BXA-24529?)



-------------------------------------------------------------------------------
booting
-------------------------------------------------------------------------------
Separate boot fpga, talks to event bus, has general purpose GPIO pins. Designed to take a CF card of bitstreams... 

0.5 MB (4 Mb) should be more than enough, and we can always do some sort of funky look-up scheme. the nice thing is we can just DD the image, we don't need to worry about any sort of filesystem or anything. 

The ATA spec is really clean, and (beyond basic abstraction necessity stuff) I can't seem to think of why I would want to have separate USB and BOOT devices, esp. when there can never actually be _real_ bus contention. 

Each FPGA will need it's own DONE, PROGRAM, INIT, and DIN pin, but... how to handle them?, esp. without running out of pins, or having too-high-density of connector? 

Sadly, there appear to be pin issues with the VQ100 part, as it really only has 60 or so IO pins, and we need:
Event bus: 30
ATA : 20+
Booting: 5 per fpga * 8 FPGAs = 40 pins or so

== total of 90 pins, i.e. what you'd hope to get from the TQ144 part. 


