This is a test to see if we can actually read and write memory properly. 

It's also a verification of whether we can synthesize this thing or not. 

We have a simple interface which, in a ping-pong fashion:

1. writes a burst pattern to a row; 
2. reads a burst pattern from a row; 

we compare what was written and what we read back and: 
1. if there's an error, we flash a LED


We generate the primary clock from the input 50 MHz clock, tripling it
to 150 MHz and then passing that output through a phase-adjusting DLL.

---------------------------------------------------------------------------
TEST LOG
---------------------------------------------------------------------------

13 November 2006
Well, it doesn't work, and the entire board then proceeds to suck down 1.5A @3.3V. 

First, check stupid stuff. The memtesttest module works, and sets
LEDERROR =0.


Now, check the UCF File: Everything is correct. 

Do we need a resistor to terminate the fracking CK/CK-? Adding one, 100 ohm... no luck. 

Signals all "look good" with oscope. 

How about DCI resistors -- we have two ~45ohm ones right
now. According to page 228 of the UG070 xilinx Virtex-4 User guide,
VRN=VRP=R=Z_o, so this should be correct.

Post-P&R Sim model works -- LEDERROR remains 0 and I can verify that
bytes are being read and written.

Is it a problem with the memclk phase? 
clkout <= clk90 -- error
clkout <= clk   -- error
clkout <=clk180 -- error
clkout <= clk270 -- error


Disable Rtt, disable DQS#

PHYSICALLY isolate the ODT line from the PCB, being careful not to cut self in process. 

IF we write all 0s we successfully read back all zeros. 

== 14 November 2006 ==

At vimal's suggestion we're making a generic jtag interface to this. Duh!

The interface is based on 3 jtag USER registers, 1-3:

USER1: controls R, W, ROWTGT, and initiates read or write operation
USER2: writes into a dual-ported memory buffer for memory write operations
USER3: reads from a dual-ported memory buffer for memory read operations


There appear to be lots of "unused states" for the startup, and I'm not sure what the heck that is.

WOW WE CAN READ OUT ROWS!!! There exist bit errors, byte errors, and frame errors, but we are very clearly taking bytes out of this ram. 

Now, with the CLKOUT being regular CLK we get a much better result, although the bytes are shifted. 

We appear to be having a probelm both with byte order and with the first word. 


  0 : 00000000
  1 : 33441122
  2 : 33441122
  3 : 33441122

A sequential buffer shows that we clearly appear to be writing the first half-word. So we're either writing one before that or writing one after that. 

We tried always writing a constant to the interface to see if jtagserialio is at fault. 

Now perhaps it's a cas issue

== 15 November 2006 ==

We still haven't fixed the CAS issues completly -- we updated the module to take CAS Latency as a generic which we use to set the necessary registers. There is very clearly a WRITE latency that is cas-dependent as well. 

Our current implementation works properly for CL=3 and 4 in sim, but
not 5. I don't understand why at all.

We still have the strange word one-off error. I'm not sure what's
causing it. Fucking with the read latency registers seems to have
(partially) fixed it although the last read-out word is wrong.

Switching from clkout= clk90 to clkout <= clk to see if that helps anything. 



for clk:        For clk180:     for clk270: 

252 : FFFF00FC  252 : 00FCFFFF  252 : FFFF00FC
253 : FFFF00FD  253 : 00FDFFFF  253 : FFFF00FD
254 : FFFF00FE  254 : 00FEFFFF  254 : FFFF00FE
255 : 00FF0000  255 : 00FF00FD  255 : 00FF0000

Now, we try screwing with the output timing of the data from DQALIGN. This isn't a bad idea, noooo.....

osel ='1' to osel = '0':


