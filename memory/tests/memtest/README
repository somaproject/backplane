This is a test to see if we can actually read and write memory properly. 

It's also a verification of whether we can synthesize this thing or not. 

We have a simple interface which, in a ping-pong fashion:

1. writes a burst pattern to a row; 
2. reads a burst pattern from a row; 

we compare what was written and what we read back and: 
1. if there's an error, we flash a LED


We generate the primary clock from the input 50 MHz clock, tripling it
to 150 MHz and then passing that output through a phase-adjusting DLL.

---------------------------------------------------------------------------
TEST LOG
---------------------------------------------------------------------------

13 November 2006
Well, it doesn't work, and the entire board then proceeds to suck down 1.5A @3.3V. 

First, check stupid stuff. The memtesttest module works, and sets
LEDERROR =0.


Now, check the UCF File: Everything is correct. 

Do we need a resistor to terminate the fracking CK/CK-? Adding one, 100 ohm... no luck. 

Signals all "look good" with oscope. 

How about DCI resistors -- we have two ~45ohm ones right
now. According to page 228 of the UG070 xilinx Virtex-4 User guide,
VRN=VRP=R=Z_o, so this should be correct.

Post-P&R Sim model works -- LEDERROR remains 0 and I can verify that
bytes are being read and written.

Is it a problem with the memclk phase? 
clkout <= clk90 -- error
clkout <= clk   -- error
clkout <=clk180 -- error
clkout <= clk270 -- error


Disable Rtt, disable DQS#

PHYSICALLY isolate the ODT line from the PCB, being careful not to cut self in process. 

IF we write all 0s we successfully read back all zeros. 

== 14 November 2006 ==

At vimal's suggestion we're making a generic jtag interface to this. Duh!

The interface is based on 3 jtag USER registers, 1-3:

USER1: controls R, W, ROWTGT, and initiates read or write operation
USER2: writes into a dual-ported memory buffer for memory write operations
USER3: reads from a dual-ported memory buffer for memory read operations


There appear to be lots of "unused states" for the startup, and I'm not sure what the heck that is.

WOW WE CAN READ OUT ROWS!!! There exist bit errors, byte errors, and frame errors, but we are very clearly taking bytes out of this ram. 

Now, with the CLKOUT being regular CLK we get a much better result, although the bytes are shifted. 

We appear to be having a probelm both with byte order and with the first word. 


  0 : 00000000
  1 : 33441122
  2 : 33441122
  3 : 33441122

A sequential buffer shows that we clearly appear to be writing the first half-word. So we're either writing one before that or writing one after that. 

We tried always writing a constant to the interface to see if jtagserialio is at fault. 

Now perhaps it's a cas issue

== 15 November 2006 ==

We still haven't fixed the CAS issues completly -- we updated the module to take CAS Latency as a generic which we use to set the necessary registers. There is very clearly a WRITE latency that is cas-dependent as well. 

Our current implementation works properly for CL=3 and 4 in sim, but
not 5. I don't understand why at all.

We still have the strange word one-off error. I'm not sure what's
causing it. Fucking with the read latency registers seems to have
(partially) fixed it although the last read-out word is wrong.

Switching from clkout= clk90 to clkout <= clk to see if that helps anything. 



for clk:        For clk180:     for clk270: 

252 : FFFF00FC  252 : 00FCFFFF  252 : FFFF00FC
253 : FFFF00FD  253 : 00FDFFFF  253 : FFFF00FD
254 : FFFF00FE  254 : 00FEFFFF  254 : FFFF00FE
255 : 00FF0000  255 : 00FF00FD  255 : 00FF0000

Now, we try screwing with the output timing of the data from DQALIGN. This isn't a bad idea, noooo.....

osel ='1' to osel = '0':


------------------------------------------
15 november 2006
------------------------------------------

For the below, clkout = clk

Seqwrite with READOFFSET = 00: 
[jonas@shannon memtest]$ sudo python control.py
Password:
Writing...
Write done. Waiting.
Reading...
  0 : 00001B40
  1 : FFFF0000
  2 : FFFF0001
  3 : FFFF0002
  4 : FFFF0003
  5 : FFFF0004
  6 : FFFF0005
  7 : FFFF0006
  8 : FFFF0007
...
251 : FFFF00FA
252 : FFFF00FB
253 : FFFF00FC
254 : FFFF00FD
255 : FFFF00FE



Seqwrite with READOFFSET = 01:
[jonas@shannon memtest]$ sudo python control.py
Writing...
Write done. Waiting.
Reading...
  0 : FFFFFFFF
  1 : 0000FFFF
  2 : 1B40FFFF
  3 : 0002FFFF
  4 : 0001FFFF
  5 : 0004FFFF
  6 : 0003FFFF
  7 : 0006FFFF
  8 : 0005FFFF
  9 : 0008FFFF
 10 : 0007FFFF
 11 : 000AFFFF
 12 : 0009FFFF
 13 : 000CFFFF
 14 : 000BFFFF
 15 : 000EFFFF
 16 : 000DFFFF
 17 : 0010FFFF
 18 : 000FFFFF
 19 : 0012FFFF
...
247 : 00F6FFFF
248 : 00F5FFFF
249 : 00F8FFFF
250 : 00F7FFFF
251 : 00FAFFFF
252 : 00F9FFFF
253 : 00FCFFFF
254 : 00FBFFFF
255 : 00FEFFFF


Seqwrite with READOFFSET = 10:
[jonas@shannon memtest]$ sudo python control.py
Writing...
Write done. Waiting.
Reading...
  0 : 0000FFFF
  1 : 1B40FFFF
  2 : 0002FFFF
  3 : 0001FFFF
  4 : 0004FFFF
  5 : 0003FFFF
  6 : 0006FFFF
  7 : 0005FFFF
  8 : 0008FFFF
  9 : 0007FFFF
 10 : 000AFFFF
 11 : 0009FFFF
 12 : 000CFFFF
 13 : 000BFFFF
...
246 : 00F6FFFF
247 : 00F5FFFF
248 : 00F8FFFF
249 : 00F7FFFF
250 : 00FAFFFF
251 : 00F9FFFF
252 : 00FCFFFF
253 : 00FBFFFF
254 : 00FEFFFF
255 : 00FDFFFF

Seqwrite with READOFFSET = 11:

[jonas@shannon memtest]$ sudo python control.py
Writing...
Write done. Waiting.
Reading...
  0 : 0000FFFF
  1 : 1B40FFFF
  2 : 0000FFFF
  3 : 0001FFFF
  4 : 0002FFFF
  5 : 0003FFFF
  6 : 0004FFFF
  7 : 0005FFFF
  8 : 0006FFFF
  9 : 0007FFFF
...
244 : 00F2FFFF
245 : 00F3FFFF
246 : 00F4FFFF
247 : 00F5FFFF
248 : 00F6FFFF
249 : 00F7FFFF
250 : 00F8FFFF
251 : 00F9FFFF
252 : 00FAFFFF
253 : 00FBFFFF
254 : 00FCFFFF
255 : 00FDFFFF

16 November 2006

now, we've instruemnted DQALIGN position registers. 

clkout <= clk: DQALIGNPOSL = 0x1D DQALIGNPOSH = 0x1D
clkout <= clk90; DQALIGNPOSL = 0D  DQALIGNPOSH = 0D
clkout <= clk270; DQALIGNPOSL = 0C   DQALIGNPOSH = 0C
