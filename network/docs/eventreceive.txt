The event receiver interface takes events off of the network and
places them on the event bus.

It reads them in and places them in a 64-deep FIFO, where they are then sent one event at a time. 

I'm modifying the event tx protocol here a bit because I'm worried about things like FIFO overflow and the like. THis will significantly add to the complexity of this particular component. 

Each Event TX is: 

16-bit NONCE
16-bit Event Count
Event addrs/data


The operation is this: 

1. read the packet
2. if there's space in the FIFO:
      commit events to FIFO
      reply to sending port with nonce/success
   else
      reply to sending port with nonce/fail


Event packets are atomic -- they either succeed or fail. 

\section{eventreceive}

1. when we get the START, we latch in the relevant bits -- NONCE,
   destmac, destport, destIP. We'll need all of them regardless of our
   action. We care about sending to the correct destination port
   because we want to be able to reply to the socket.

2. we check to see if ECNT < EFREE; if so, we start the network event fifo and let it have exclusive access to the packet buffer while simultaneously starting the event response writer. 

Either the event response writer or the network event fifo can finish,
so their done signals set latches.

\section{Network Event FIFO}

The network event fifo's addressing scheme assumes that the first
event starts at ADDR= 0, and they are packed tightly, and they are
readable with a single-cycle latency (ala block-ram).

On the output side, every ECYCLE we check and see if there is anything
in the FIFO, and if there is, we set up a register set to send it on
the next ECYCLE. 

\section{Event Response Writer}

The event response writer writes: 
1. all header data
2. the nonce
3. the success / failure result

