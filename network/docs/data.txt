The data interface

Our goal here is to acquire up to one 560-byte packet from each
devicemux'd device (64 total) and to buffer them for transmit out the
TX interface.

Note that this data is all determined to be latency-insensitive. Thus,
deep fifos and buffering are acceptable.

\section{TX Bus Allocation} 

Data Bus devices are constrained to transmit no more than one packet
every 50 ecycles (1 ms). But since our double-wide data bus aggregator
can acquire two data packets per ECYCLE and in the worst-case we can
only transmit < 2 data bus packets per ecycle (if the Event network
packets are at max size), we will potentiall need substantial buffering. 

\section{Retransmission} 

Because our UDP interface is a lossy protocol, we'd like at least a
rudimentary mechanism for data packet retransmission. The
protocol-level support for this is described in the protocol
description section. 

However, our retransmission buffer size is limited. we use the TX fifo
as our retx buffer as well. Our 128kx16 is viewed as having 256 packet
locations. 

The memory arbitration module keeps a lookup table that matches the
packet identifier of (src, type, id) to the relevant location in the
TX buffer, in a constant-lookup-time manner. 

An example is illustrative. If we receive a packet from source 4, of
type 2, with a sequence ID of 0x12345678, we:
1. write it to the next slot in the reTX fifo, which is 17. 
2. update the ReTX Pointer Table such that location 000100 | 10 | 0x8 
now contains 17. 

for a retx request, we perform a similar lookup and pass the contents
of packet 17 to the ReTX interface. 

But what if that location has since been overwritten by some other
packet? It is the responsibility of the ReTX device to make sure that
this is the correct (src, type, id) and transmit an "unavailable"
response if that's not the case.

\section{Data Bus Acquire}

The data bus acquire interface takes a data bus packet and: 

1. event-cycle aligns it, so it is guaranteed to be available on the
   next ecycle.
2. converts it to a 16-bit-wide packet
3. measures the length

It uses a double-fifo. On the cycle following ecycle-assertion, LEN
contains the length of the packet in bytes, not words; if LEN =0 then
there is no packet.

\section{Data Bus Packet Generation} 

1. query A|B for LEN > 0
2. copy data into current packet
3. Write header
4. write sequence
5. commit to FIFO

The data bus packet generator generates one or two events every ecycle, which are ready for processing at the end of the event cycle. It uses a four-deep fifo such that the packets can be read out on the subsequent ecycle. 

Note that the fifo output stage runs at the Memory Clock speed (100 MHz). 

The data bus packet gen interface is such that: 
1. when FIFOVALID is asserted, ADDR and DOUT can be used to read the contents of the current packet, with a one-cycle (blockram-like) read latency
2. when the reader is done with the current packet, it asserts FIFONEXT for one tick to advance the internal fifo pointer. 

\section{Memory Arbitration} 

The memory arbitration interface must, each ECYCLE (1000 ticks, or 4000 bytes):

1. write up to 2 packets into memory
2. fill the output fifo with up to 2 new packets
3. respond to one retx request. 

The memory arbitration interface's interface to, well, everything is via address, data, and write-enable lines. 

THe memory arbitration interface is composed of three submodules. Each interface is simply muxed access to the RAM, so each interface must have a good model of the relevant latencies that occur externally due to the ZBT SRAM and interface. 


\subsection{Memory Packet Writer}
The memory packet writer interfaces with the DAta bus packet generator and is responsible for reading out up to two packets each event cycle and writing them 
to the RAM interface. It also keeps track of the base pointer for the current packet. 

AT the assertion of DONE, BP points to the next empty slot in the FIFO. 

In the event of a packet being written, at some point during the cycle SRC, ID, TYPE, and IDWE will be asserted to inform the ReTX module of the written location of the packet with these parameters. 

\subsection{Memory Packet Transmission} 
The TX interface waits until TXFIFOFULL is not asserted and then writes into the tx buffer, asserting TXDONE to indicate it is, in fact, done. 

\section{Output FIFO} 

The output fifo is a simple three-deep fifo which handles talking to
the TX mux and clock domain conversion.
d   
