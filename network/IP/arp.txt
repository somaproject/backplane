ARP CACHE

The arp cache is the most challenging portion of the entire system. 

To match entries, we configure 2^ARPSIZE sets of LUTs to match a given IP address in a content-addressable memory fashion. We store the actual MAC addresses in a chunk of BlockSelect+ RAM 8 bytes away from each other. 

Thus, there are 0 to 2^ARPSIZE-1 of these matching CLB configurations. Retreiving the actual MAC address will be somewhat slow, but the match detection should be near-instantaneous. The entire system is generalized, such that we can work with IP addresses as small as we like. 

The only real downside is that the interface to obtain the MAC address and look up the IP address could be -WIDE-; we solve that by having a 2-bit address line and clocking out the bytes (since these are going to be latched into internal registers anyway. 

The ARP cache has a TX and an RX side; the TX side can only query and read addresses, the RX side can only write them. 

On the TX side, we have: 

IPout[4IPN-1:0]

MACout[15:0]
MACoutaddr[1:0]

VERIFY : start verification process
VERIFYDONE : goes high to indicate the completed status of a cache query
HITMISS : high if the IP address is in there. 

on the input side, we always write, but the actual success of the write is application-dependent

MACin[15:0]
MACinaddr[1:0]
MACinWE
IPin[4IPN-1:0]
IPinWE

The sequence of input writing is "Write the MACin, and then write the IPin."

The arp cache contains a replacement module, ARPREPL, which has a REPLIN[ARPSIZE-1:0], REPLOUT[ARPSIZE-1:0], input and a REPL[ARPSIZE-1:0] output, and 2^ARPSIZE entries. This has a simple "WE" entry on it as well" -- at some point we'll implement a pseudo-LRU strategy here, but for now, we don't really care. 

The MAC addresses themselves are stored in a chunk of dual-ported blockselect+ RAM, and we index into them via the LSBs. At the moment, we have two IPLUTs that we use, one for read and one for write, athough if this all gets too big we might revisit that plan. 


-----------------------------------------------------------------------
IPLUT CAM
-----------------------------------------------------------------------

The LUT CAMs are going to be large; a 16-bit IP address and a 32-entry ARP cache gives us a 5*32=160 slices; or 40 CLBs (or so) out of 480. That's 10% of the -200 part. We also have to deal with the problem of race conditions between look-up and write. 

Each IPMatch is a series of SRLE16s configured as a LUT. The question becomes how to write to the LUT in a manner that makes sense. 

The interface is defined as follows:
Two identical query interfaces:
IPA : IPN-length IP query interface
IPQA : high for one cycle to begin the query
DONEA : goes high to indicate that the output of MATCH, MADDROUT is the result of As query. MATCH, MADDROUT are only guaranteed to be high for that pulse, so DONEA is usually used to latch these outputs. 

There is a similar B interface. 

We want to avoid race conditions, which means that we sequence through:
Read A
Read B

The EN on a particular IP match disables it, but we should only let these be registered (i.e. their state change) -between- READA and READB states, to guarantee consistent data. 

The LUT reserialize stuff is a bit confusing, but essentially we can't just clock in the necessary bits, because of the way the SRL16E works. 
