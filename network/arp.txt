ARP CACHE

The arp cache is the most challenging portion of the entire system. 

To match entries, we configure 2^ARPSIZE sets of LUTs to match a given IP address in a content-addressable memory fashion. We store the actual MAC addresses in a chunk of BlockSelect+ RAM 8 bytes away from each other. 

Thus, there are 0 to 2^ARPSIZE-1 of these matching CLB configurations. Retreiving the actual MAC address will be somewhat slow, but the match detection should be near-instantaneous. The entire system is generalized, such that we can work with IP addresses as small as we like. 

The only real downside is that the interface to obtain the MAC address and look up the IP address could be -WIDE-; we solve that by having a 2-bit address line and clocking out the bytes (since these are going to be latched into internal registers anyway. 

The ARP cache has a TX and an RX side; the TX side can only query and read addresses, the RX side can only write them. 

On the TX side, we have: 

IPout[IPN-1:0]

MACout[15:0]
MACoutaddr[1:0]

VERIFY : start verification process
VERIFYDONE : goes high to indicate the completed status of a cache query
HITMISS : high if the IP address is in there. 

on the input side, we always write, but the actual success of the write is application-dependent

MACin[15:0]
MACinaddr[1:0]
MACinWE
IPin[IPN-1:0]
IPin[15:0]
IPinWE

The sequence of input writing is "Write the MACin, and then write the IPin."

The arp cache contains a replacement module, ARPREPL, which has a REPLIN[ARPSIZE-1:0], REPLOUT[ARPSIZE-1:0], input and a REPL[ARPSIZE-1:0] output, and 2^ARPSIZE entries. This has a simple "WE" entry on it as well" -- at some point we'll implement a pseudo-LRU strategy here, but for now, we don't really care. 

The MAC addresses themselves are stored in a chunk of dual-ported blockselect+ RAM, and we index into them via the LSBs. At the moment, we have two IPLUTs that we use, one for read and one for write, athough if this all gets too big we might revisit that plan. 



