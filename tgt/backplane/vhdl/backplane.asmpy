"""
How to boot off a file? At the moment we're going to use a fixed filename
for the device, "network.bit"
0. get Handle
1. send filename / open file events
2. open file, save file length
2. currentpos = 0
3. while currentpos < filelength
4. send a req for 512 bytes
5. process incoming bytes by sending to the interface and the commiting the output
   word
   
# and the event dispatches
For the time being, event 100-105 will simply
trigger the appropriate writes
to the serial peripheral.

0x08-0x0F are the relevant commands
0x08 (000): lower 16 bits of mask
0x09 (001): upper 4 bits of mask
0x0A (010): write data
0x0B (011): toggle FPROG
0x0C (100): send the current buffer

"""

env = createEnvironment()
currentFileHandle = env.createVariable("currentFileHandle")
currentFileSize = env.createVariable("currentFileSize")
currentState = env.createVariable("currentState")
nextState = env.createVariable("nextState")


### CONSTANTS
JTAGADDR = 7
BOOTSTOREADDR = 2

EVENTOUT_CMD = 0x80
EVENTOUT_SRC = 0x87
EVENTOUT_DATA0 = 0x81
EVENTOUT_DATA1 = 0x82
EVENTOUT_DATA2 = 0x83
EVENTOUT_DATA3 = 0x84
EVENTOUT_DATA4 = 0x85
EVENTPROC_ENABLE = 0x89

FPROGOUT_MASKL = 0x08
FPROGOUT_MASKH = 0x09
FPROGOUT_DATA = 0x0A
FPROGOUT_FPROG = 0x0B
FPROGOUT_SEND = 0x0C


### STATES
STATE_GETHANDLE = 0
STATE_SENDFILENAME = 1
STATE_OPENFILE = 2
STATE_GETFILESIZE = 3
STATE_FILE_SENDDATA = 4


def testProc():
  proc = env.createProc("testProc")
  proc.load(0, 0)
  proc.load(0, 0xFFFF)
  proc.output(FPROGOUT_MASKL, 0)
  proc.output(FPROGOUT_FPROG, 0)
  proc.foreverLoop()
  
def jumpIfEqual(self, reg, const, addr):
  """
  if reg == const, jump to addr

  """
  proc = env.createProc()
  tmp = proc.createVariable("temp")
  proc.load(tmp, const)
  proc.sub(tmp, reg)
  proc.jz(addr)
  

def createEventCycleProc():
  ecp = env.createECycleProc()
  ecp.jumpIfEqual(env.nextState, STATE_GETHANDLE, "proc_state_gethandle")
  ecp.jumpIfEqual(env.nextState, STATE_, "proc_state_gethandle")
  ecp.jumpIfEqual(env.nextState, STATE_GETHANDLE, "proc_state_gethandle")
  ecp.jumpIfEqual(env.nextState, STATE_GETHANDLE, "proc_state_gethandle")
  ecp.jumpIfEqual(env.nextState, STATE_GETHANDLE, "proc_state_gethandle")
  ecp.jumpIfEqual(env.nextState, STATE_GETHANDLE, "proc_state_gethandle")
  
  ecp.foreverLoop()

def createMaskWriteProc():
  ### the mask writing
  maskp = env.createEProc((100, 100), (0, 255))
  rxword1 = maskp.createVariable("rxWord1")
  rxword2 = maskp.createVariable("rxWord2")
  maskp.move(rxword1, ereg.edata[0])
  maskp.move(rxword2, ereg.edata[1])
  maskp.output(0x08, rxword1)
  maskp.output(0x09, rxword2)

def createDataWritingProc():
  ### The data writing: 
  datap = env.createEProc((101, 101), (0, 255))
  tmp = datap.createVariable("tmp")
  for i in xrange(4):
    datap.move(tmp, ereg.edata[i])
    datap.output(0x08+2, tmp)

def createProgAssertionProc():
  ### The prog assertion

  progp = env.createEProc((102, 102), (0, 255))
  progp.output(0x08 + 3, 0x00)

def createDataCommitProc():
  ### The data load assertion
  dataloadp = env.createEProc((103, 103), (0, 255))
  dataloadp.output(0x08 + 4, 0x00)

def bootStoreHandleSetRX():
  proc = env.createEProc((0x90, 0x90), (BOOTSTOREADDR, BOOTSTOREADDR))
  # put the handle int he handle buffer
  proc.move(env.currentFileHandle, ereg.edata[1])
  

def sendOpenHandleEvent():
  proc = env.createProc("sendOpenHandleEvent")
  tmp = proc.createVariable("handleOpenTemp")
  # write the dest
  proc.load(tmp, BOOTSTOREADDR)
  proc.output(EVENTOUT_SRC, tmp)
  # write the command
  proc.load(tmp, 0x90)
  proc.output(EVENTOUT_CMD, tmp)


### The -respond-and-output-bytes
def createDataToBootSerProc():
  """
  Receives event 0x94 from bootstore (new data) and sends it out
  via the serial interface
  
  """
  datap = env.createEProc((0x94, 0x94), (2, 2))
  tmp = datap.createVariable("tmp")
  for i in xrange(4):

    datap.move(tmp, ereg.edata[i+1])
    datap.output(0x08+2, tmp)
  # then commit
  datap.output(0x08 + 4, 0x00)


def createEnableEventCycleProc():
  newproc = env.createProc("newproc")
  y = newproc.createVariable("y")
  newproc.load(y, 1)
  newproc.output(EVENTPROC_ENABLE, y)
  newproc.foreverLoop()

testProc()
