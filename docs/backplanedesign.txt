Backplane redesign, part two

-----------------------------------------------
Bandwidth Allocation
-----------------------------------------------

THe first question to address is what sort of bandwidth requirements
we have. The original event bus required an event cycle every
timestamp (every 20 us), between 40 devices.

With our new routing scheme, each event has 12 bytes of data and a
1-byte comma character. that's 13 byte symbols, 40 events per cycle,

50k cycles/ second * 40 events/cycle * 13 bytes/event = 208 Mbps of
raw data, and thus (via 8b/10b) = 260 Mbps.

I was worried about the addressing overhead, but the FPGA can handle
the routing. 

The TX side is fine, we don't send that much data. 

Allocation of events: 
32 DSPs
2 ADIO
2 NEP
1 NET
1 ETHER
1 SYS
1 TIMER/Coordinator
-----------------------------
40 


------------------------------------------------
Booting
------------------------------------------------

We're going to use the SATA serial interface and the SATA backplane
connectors. The problem is "how do we boot the FPGAs". We're going to 8b/10b-encode a configuration bitstream and use the 12v power connector. 

------------------------------------------------
Connector
------------------------------------------------

The SATA backplane connector will be used; SATA signal pairs have a
100-ohm impedance.

In terms of actual connectors, we have a few options: 

On the DSPboard side, we have: 
  The device plug with the strattle mount: 87679-0003 (Arrow has 1k)
  Device plug smt without jumpers -- 87703-0001 (arrow has 1k)

On the backplane side, we have two of our standard-height connectors: 
  1. 87713-1001 -- SMT mount

---- 
PCB 
---

For high-speed serial interconnect, the SATA standard recommends "differential microstrip traces (100+/- 5 ohms) over a ground plane (single ended 50+/-2.5 ohms). However, this results in a trace width and spacing that is just unmanagable. 

According to PCBexpress, these processes are dependent on the exact
geometry of the copper between the traces.

See 4pcb.stack.txt
    pcb-express1.txt
    pcb-express-2.txt

A good number to go with is 7-8 mil, and so we're using the following:
epsilon = 4.6
w = 9 # trace width 
s = 9. # trace separation 
t = 1.4 # trace thickness 
h = 7.5 # height above ground plane

Z0 =  59.4565832263
Zdiff =  100.876181706

A little high on the common-mode impedance, but the standard suggests
that doesn't really matter anyway.



-------------------------------------------------
Devices and timing
-------------------------------------------------
The suggested xilinx app note is for -5 spartan-3 devices. 
We need to show that -4 devices can do 240 Mbps. 

Power
TPS786xx -- ubiquitus, many voltages, etc.  1.5A output
We're going to use the KTT (DDPAK-5) package because it appears to be more widely available and looks like it can handle more power. 


switching supplies are a pain to design and use and mount; I'm just
going to use the PTH05010W power supply module... in fact, I'm going
to use three:

----------------------------------------
Clocking
----------------------------------------

we have an input clock rate of 65 MHz
an output bit/clock rate of 260 MHz
and an rx rate of 260 + epsilon

input --> x4 --> tx clock --> 32/31 --> rxclk --> phasedelay




----------------------------------------
Bus routing, clocks, configuration
----------------------------------------
we have an EVENTCE signal, internally, which gates an input event. 

Each event cycle sends 500 Bytes to all devices; an event bus transaction consists of:

20 bytes of header
40*12 bytes of 12-byte events, in order of sender ID .

The header consists of:
1. a k28.5 sync comma
2. two 6-byte device configuration packets:
byte 0: device can send on this cycle
byte 1: lsb: the first event in the sequence is for this device
byte 2: lsb: the 8th evenet in the sequence is for this device
3. 1 buffer byte

[the events]

[6 end bytes] 

Device transmit:
every device must respond with a K28.5 at the beginning of each event cycle

Any time during an event cycle a device can send an event, which in this case is a 17-byte packet of data prefaced with a K28.4 comma character

A device may also send up to 300 bytes of data, if selected, in the following needlessly complex format

to begin data, send K28.2
to end data, send K28.3
to end a packet, send K28.4

This is depressingly like token ring. 


---------------------------------------------------------------------------
Data receiver
---------------------------------------------------------------------------
The data receiver receives the relevant comma characters and handles
the setting of DOEN, DDONE, etc. 

A K28.2 -> sets DOEN high
a K28.3 -> sets DOEN low
a K28.4 -> sets DDONE high for a tick
an ERR at any point sets DABORT high until the next ECYCLE

Ecycle is registered and then used as a reset; since T_txbyteclock > T_rxbyteclock, ecycle will always trigger. 


Data buffers... 


--------------------------------------------------------------------------
device receiver
--------------------------------------------------------------------------
We still need to check the error handling here; the goal is that no
error-full events will ever get through, and an error causes us to
abort the rest of the event cycle.


--------------------------------------------------------------------------
device transmitter
--------------------------------------------------------------------------

how do we handle the -actual- transmission; it's fine and dandy to say that we're going to send an event at "some point", but when are these going to actually be received? 

There are hard real-time expectations. That said, I'd just as soon
send them whenever, with the understanding that if they are sent such
that the last byte occurs 10 ticks prior to the end of the ECYCLE AS
DEFINED IN THE CORE, then we'll make it.

So we should just be able to clock in an event at any time. 

But we're limited to one per ecycle. But we make the application deal with that. 
At the start of an event we 

